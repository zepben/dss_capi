/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: zepben/protobuf/hc/opendss/Diagnostics.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "zepben/protobuf/hc/opendss/Diagnostics.pb-c.h"
void   summary_report__init
                     (SummaryReport         *message)
{
  static const SummaryReport init_value = SUMMARY_REPORT__INIT;
  *message = init_value;
}
size_t summary_report__get_packed_size
                     (const SummaryReport *message)
{
  assert(message->base.descriptor == &summary_report__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t summary_report__pack
                     (const SummaryReport *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &summary_report__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t summary_report__pack_to_buffer
                     (const SummaryReport *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &summary_report__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SummaryReport *
       summary_report__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SummaryReport *)
     protobuf_c_message_unpack (&summary_report__descriptor,
                                allocator, len, data);
}
void   summary_report__free_unpacked
                     (SummaryReport *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &summary_report__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   event_log_entry__init
                     (EventLogEntry         *message)
{
  static const EventLogEntry init_value = EVENT_LOG_ENTRY__INIT;
  *message = init_value;
}
size_t event_log_entry__get_packed_size
                     (const EventLogEntry *message)
{
  assert(message->base.descriptor == &event_log_entry__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t event_log_entry__pack
                     (const EventLogEntry *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &event_log_entry__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t event_log_entry__pack_to_buffer
                     (const EventLogEntry *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &event_log_entry__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EventLogEntry *
       event_log_entry__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EventLogEntry *)
     protobuf_c_message_unpack (&event_log_entry__descriptor,
                                allocator, len, data);
}
void   event_log_entry__free_unpacked
                     (EventLogEntry *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &event_log_entry__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   event_log__init
                     (EventLog         *message)
{
  static const EventLog init_value = EVENT_LOG__INIT;
  *message = init_value;
}
size_t event_log__get_packed_size
                     (const EventLog *message)
{
  assert(message->base.descriptor == &event_log__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t event_log__pack
                     (const EventLog *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &event_log__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t event_log__pack_to_buffer
                     (const EventLog *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &event_log__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EventLog *
       event_log__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EventLog *)
     protobuf_c_message_unpack (&event_log__descriptor,
                                allocator, len, data);
}
void   event_log__free_unpacked
                     (EventLog *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &event_log__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   taps_report__init
                     (TapsReport         *message)
{
  static const TapsReport init_value = TAPS_REPORT__INIT;
  *message = init_value;
}
size_t taps_report__get_packed_size
                     (const TapsReport *message)
{
  assert(message->base.descriptor == &taps_report__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t taps_report__pack
                     (const TapsReport *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &taps_report__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t taps_report__pack_to_buffer
                     (const TapsReport *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &taps_report__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
TapsReport *
       taps_report__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (TapsReport *)
     protobuf_c_message_unpack (&taps_report__descriptor,
                                allocator, len, data);
}
void   taps_report__free_unpacked
                     (TapsReport *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &taps_report__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   loop_report__init
                     (LoopReport         *message)
{
  static const LoopReport init_value = LOOP_REPORT__INIT;
  *message = init_value;
}
size_t loop_report__get_packed_size
                     (const LoopReport *message)
{
  assert(message->base.descriptor == &loop_report__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t loop_report__pack
                     (const LoopReport *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &loop_report__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t loop_report__pack_to_buffer
                     (const LoopReport *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &loop_report__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
LoopReport *
       loop_report__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (LoopReport *)
     protobuf_c_message_unpack (&loop_report__descriptor,
                                allocator, len, data);
}
void   loop_report__free_unpacked
                     (LoopReport *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &loop_report__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   isolated_area__init
                     (IsolatedArea         *message)
{
  static const IsolatedArea init_value = ISOLATED_AREA__INIT;
  *message = init_value;
}
size_t isolated_area__get_packed_size
                     (const IsolatedArea *message)
{
  assert(message->base.descriptor == &isolated_area__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t isolated_area__pack
                     (const IsolatedArea *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &isolated_area__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t isolated_area__pack_to_buffer
                     (const IsolatedArea *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &isolated_area__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
IsolatedArea *
       isolated_area__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (IsolatedArea *)
     protobuf_c_message_unpack (&isolated_area__descriptor,
                                allocator, len, data);
}
void   isolated_area__free_unpacked
                     (IsolatedArea *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &isolated_area__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   isolated_element__init
                     (IsolatedElement         *message)
{
  static const IsolatedElement init_value = ISOLATED_ELEMENT__INIT;
  *message = init_value;
}
size_t isolated_element__get_packed_size
                     (const IsolatedElement *message)
{
  assert(message->base.descriptor == &isolated_element__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t isolated_element__pack
                     (const IsolatedElement *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &isolated_element__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t isolated_element__pack_to_buffer
                     (const IsolatedElement *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &isolated_element__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
IsolatedElement *
       isolated_element__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (IsolatedElement *)
     protobuf_c_message_unpack (&isolated_element__descriptor,
                                allocator, len, data);
}
void   isolated_element__free_unpacked
                     (IsolatedElement *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &isolated_element__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   isolated_buses_report__init
                     (IsolatedBusesReport         *message)
{
  static const IsolatedBusesReport init_value = ISOLATED_BUSES_REPORT__INIT;
  *message = init_value;
}
size_t isolated_buses_report__get_packed_size
                     (const IsolatedBusesReport *message)
{
  assert(message->base.descriptor == &isolated_buses_report__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t isolated_buses_report__pack
                     (const IsolatedBusesReport *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &isolated_buses_report__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t isolated_buses_report__pack_to_buffer
                     (const IsolatedBusesReport *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &isolated_buses_report__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
IsolatedBusesReport *
       isolated_buses_report__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (IsolatedBusesReport *)
     protobuf_c_message_unpack (&isolated_buses_report__descriptor,
                                allocator, len, data);
}
void   isolated_buses_report__free_unpacked
                     (IsolatedBusesReport *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &isolated_buses_report__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   losses_entry__init
                     (LossesEntry         *message)
{
  static const LossesEntry init_value = LOSSES_ENTRY__INIT;
  *message = init_value;
}
size_t losses_entry__get_packed_size
                     (const LossesEntry *message)
{
  assert(message->base.descriptor == &losses_entry__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t losses_entry__pack
                     (const LossesEntry *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &losses_entry__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t losses_entry__pack_to_buffer
                     (const LossesEntry *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &losses_entry__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
LossesEntry *
       losses_entry__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (LossesEntry *)
     protobuf_c_message_unpack (&losses_entry__descriptor,
                                allocator, len, data);
}
void   losses_entry__free_unpacked
                     (LossesEntry *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &losses_entry__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   losses_totals__init
                     (LossesTotals         *message)
{
  static const LossesTotals init_value = LOSSES_TOTALS__INIT;
  *message = init_value;
}
size_t losses_totals__get_packed_size
                     (const LossesTotals *message)
{
  assert(message->base.descriptor == &losses_totals__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t losses_totals__pack
                     (const LossesTotals *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &losses_totals__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t losses_totals__pack_to_buffer
                     (const LossesTotals *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &losses_totals__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
LossesTotals *
       losses_totals__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (LossesTotals *)
     protobuf_c_message_unpack (&losses_totals__descriptor,
                                allocator, len, data);
}
void   losses_totals__free_unpacked
                     (LossesTotals *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &losses_totals__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   node_mismatch__init
                     (NodeMismatch         *message)
{
  static const NodeMismatch init_value = NODE_MISMATCH__INIT;
  *message = init_value;
}
size_t node_mismatch__get_packed_size
                     (const NodeMismatch *message)
{
  assert(message->base.descriptor == &node_mismatch__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t node_mismatch__pack
                     (const NodeMismatch *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &node_mismatch__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t node_mismatch__pack_to_buffer
                     (const NodeMismatch *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &node_mismatch__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NodeMismatch *
       node_mismatch__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NodeMismatch *)
     protobuf_c_message_unpack (&node_mismatch__descriptor,
                                allocator, len, data);
}
void   node_mismatch__free_unpacked
                     (NodeMismatch *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &node_mismatch__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   kvbase_mismatch__init
                     (KVBaseMismatch         *message)
{
  static const KVBaseMismatch init_value = KVBASE_MISMATCH__INIT;
  *message = init_value;
}
size_t kvbase_mismatch__get_packed_size
                     (const KVBaseMismatch *message)
{
  assert(message->base.descriptor == &kvbase_mismatch__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t kvbase_mismatch__pack
                     (const KVBaseMismatch *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &kvbase_mismatch__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t kvbase_mismatch__pack_to_buffer
                     (const KVBaseMismatch *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &kvbase_mismatch__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
KVBaseMismatch *
       kvbase_mismatch__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (KVBaseMismatch *)
     protobuf_c_message_unpack (&kvbase_mismatch__descriptor,
                                allocator, len, data);
}
void   kvbase_mismatch__free_unpacked
                     (KVBaseMismatch *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &kvbase_mismatch__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor summary_report__field_descriptors[22] =
{
  {
    "caseName",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, casename),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "solved",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, solved),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mode",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, mode),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "number",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, number),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "loadMult",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, loadmult),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "numDevices",
    6,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, numdevices),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "numBuses",
    7,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, numbuses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "numNodes",
    8,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, numnodes),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "iterations",
    9,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, iterations),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "controlMode",
    10,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, controlmode),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "controlIterations",
    11,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, controliterations),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mostIterationsDone",
    12,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, mostiterationsdone),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "year",
    13,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, year),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hour",
    14,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, hour),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "maxPuVoltage",
    15,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, maxpuvoltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "minPuVoltage",
    16,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, minpuvoltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "totalMW",
    17,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, totalmw),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "totalMvar",
    18,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, totalmvar),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mwLosses",
    19,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, mwlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pctLosses",
    20,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, pctlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mvarLosses",
    21,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, mvarlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "frequency",
    22,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(SummaryReport, frequency),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned summary_report__field_indices_by_name[] = {
  0,   /* field[0] = caseName */
  10,   /* field[10] = controlIterations */
  9,   /* field[9] = controlMode */
  21,   /* field[21] = frequency */
  13,   /* field[13] = hour */
  8,   /* field[8] = iterations */
  4,   /* field[4] = loadMult */
  14,   /* field[14] = maxPuVoltage */
  15,   /* field[15] = minPuVoltage */
  2,   /* field[2] = mode */
  11,   /* field[11] = mostIterationsDone */
  20,   /* field[20] = mvarLosses */
  18,   /* field[18] = mwLosses */
  6,   /* field[6] = numBuses */
  5,   /* field[5] = numDevices */
  7,   /* field[7] = numNodes */
  3,   /* field[3] = number */
  19,   /* field[19] = pctLosses */
  1,   /* field[1] = solved */
  16,   /* field[16] = totalMW */
  17,   /* field[17] = totalMvar */
  12,   /* field[12] = year */
};
static const ProtobufCIntRange summary_report__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 22 }
};
const ProtobufCMessageDescriptor summary_report__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.SummaryReport",
  "SummaryReport",
  "SummaryReport",
  "zepben.protobuf.hc.opendss",
  sizeof(SummaryReport),
  22,
  summary_report__field_descriptors,
  summary_report__field_indices_by_name,
  1,  summary_report__number_ranges,
  (ProtobufCMessageInit) summary_report__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor event_log_entry__field_descriptors[7] =
{
  {
    "hour",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, hour),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sec",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, sec),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "controlIter",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, controliter),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "iteration",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, iteration),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "element",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, element),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "action",
    6,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, action),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "event",
    7,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(EventLogEntry, event),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned event_log_entry__field_indices_by_name[] = {
  5,   /* field[5] = action */
  2,   /* field[2] = controlIter */
  4,   /* field[4] = element */
  6,   /* field[6] = event */
  0,   /* field[0] = hour */
  3,   /* field[3] = iteration */
  1,   /* field[1] = sec */
};
static const ProtobufCIntRange event_log_entry__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor event_log_entry__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.EventLogEntry",
  "EventLogEntry",
  "EventLogEntry",
  "zepben.protobuf.hc.opendss",
  sizeof(EventLogEntry),
  7,
  event_log_entry__field_descriptors,
  event_log_entry__field_indices_by_name,
  1,  event_log_entry__number_ranges,
  (ProtobufCMessageInit) event_log_entry__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor event_log__field_descriptors[1] =
{
  {
    "logEntry",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(EventLog, n_logentry),
    offsetof(EventLog, logentry),
    &event_log_entry__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned event_log__field_indices_by_name[] = {
  0,   /* field[0] = logEntry */
};
static const ProtobufCIntRange event_log__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor event_log__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.EventLog",
  "EventLog",
  "EventLog",
  "zepben.protobuf.hc.opendss",
  sizeof(EventLog),
  1,
  event_log__field_descriptors,
  event_log__field_indices_by_name,
  1,  event_log__number_ranges,
  (ProtobufCMessageInit) event_log__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor taps_report__field_descriptors[6] =
{
  {
    "name",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(TapsReport, name),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tap",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(TapsReport, tap),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "min",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(TapsReport, min),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "max",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(TapsReport, max),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "step",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(TapsReport, step),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "position",
    6,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(TapsReport, position),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned taps_report__field_indices_by_name[] = {
  3,   /* field[3] = max */
  2,   /* field[2] = min */
  0,   /* field[0] = name */
  5,   /* field[5] = position */
  4,   /* field[4] = step */
  1,   /* field[1] = tap */
};
static const ProtobufCIntRange taps_report__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor taps_report__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.TapsReport",
  "TapsReport",
  "TapsReport",
  "zepben.protobuf.hc.opendss",
  sizeof(TapsReport),
  6,
  taps_report__field_descriptors,
  taps_report__field_indices_by_name,
  1,  taps_report__number_ranges,
  (ProtobufCMessageInit) taps_report__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor loop_report__field_descriptors[5] =
{
  {
    "meter",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoopReport, meter),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lineA",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoopReport, linea),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lineB",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LoopReport, lineb),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "parallel",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(LoopReport, parallel),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "looped",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(LoopReport, looped),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned loop_report__field_indices_by_name[] = {
  1,   /* field[1] = lineA */
  2,   /* field[2] = lineB */
  4,   /* field[4] = looped */
  0,   /* field[0] = meter */
  3,   /* field[3] = parallel */
};
static const ProtobufCIntRange loop_report__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor loop_report__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.LoopReport",
  "LoopReport",
  "LoopReport",
  "zepben.protobuf.hc.opendss",
  sizeof(LoopReport),
  5,
  loop_report__field_descriptors,
  loop_report__field_indices_by_name,
  1,  loop_report__number_ranges,
  (ProtobufCMessageInit) loop_report__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor isolated_area__field_descriptors[3] =
{
  {
    "level",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(IsolatedArea, level),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "element",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(IsolatedArea, element),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "loads",
    3,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_STRING,
    offsetof(IsolatedArea, n_loads),
    offsetof(IsolatedArea, loads),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned isolated_area__field_indices_by_name[] = {
  1,   /* field[1] = element */
  0,   /* field[0] = level */
  2,   /* field[2] = loads */
};
static const ProtobufCIntRange isolated_area__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor isolated_area__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.IsolatedArea",
  "IsolatedArea",
  "IsolatedArea",
  "zepben.protobuf.hc.opendss",
  sizeof(IsolatedArea),
  3,
  isolated_area__field_descriptors,
  isolated_area__field_indices_by_name,
  1,  isolated_area__number_ranges,
  (ProtobufCMessageInit) isolated_area__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor isolated_element__field_descriptors[2] =
{
  {
    "name",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(IsolatedElement, name),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "buses",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_STRING,
    offsetof(IsolatedElement, n_buses),
    offsetof(IsolatedElement, buses),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned isolated_element__field_indices_by_name[] = {
  1,   /* field[1] = buses */
  0,   /* field[0] = name */
};
static const ProtobufCIntRange isolated_element__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor isolated_element__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.IsolatedElement",
  "IsolatedElement",
  "IsolatedElement",
  "zepben.protobuf.hc.opendss",
  sizeof(IsolatedElement),
  2,
  isolated_element__field_descriptors,
  isolated_element__field_indices_by_name,
  1,  isolated_element__number_ranges,
  (ProtobufCMessageInit) isolated_element__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor isolated_buses_report__field_descriptors[3] =
{
  {
    "disconnectedBuses",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_STRING,
    offsetof(IsolatedBusesReport, n_disconnectedbuses),
    offsetof(IsolatedBusesReport, disconnectedbuses),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "isolatedSubAreas",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(IsolatedBusesReport, n_isolatedsubareas),
    offsetof(IsolatedBusesReport, isolatedsubareas),
    &isolated_area__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "isolatedElements",
    3,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(IsolatedBusesReport, n_isolatedelements),
    offsetof(IsolatedBusesReport, isolatedelements),
    &isolated_element__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned isolated_buses_report__field_indices_by_name[] = {
  0,   /* field[0] = disconnectedBuses */
  2,   /* field[2] = isolatedElements */
  1,   /* field[1] = isolatedSubAreas */
};
static const ProtobufCIntRange isolated_buses_report__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor isolated_buses_report__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.IsolatedBusesReport",
  "IsolatedBusesReport",
  "IsolatedBusesReport",
  "zepben.protobuf.hc.opendss",
  sizeof(IsolatedBusesReport),
  3,
  isolated_buses_report__field_descriptors,
  isolated_buses_report__field_indices_by_name,
  1,  isolated_buses_report__number_ranges,
  (ProtobufCMessageInit) isolated_buses_report__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor losses_entry__field_descriptors[4] =
{
  {
    "element",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(LossesEntry, element),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "kwLosses",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesEntry, kwlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pctPower",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesEntry, pctpower),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "kvarLosses",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesEntry, kvarlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned losses_entry__field_indices_by_name[] = {
  0,   /* field[0] = element */
  3,   /* field[3] = kvarLosses */
  1,   /* field[1] = kwLosses */
  2,   /* field[2] = pctPower */
};
static const ProtobufCIntRange losses_entry__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor losses_entry__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.LossesEntry",
  "LossesEntry",
  "LossesEntry",
  "zepben.protobuf.hc.opendss",
  sizeof(LossesEntry),
  4,
  losses_entry__field_descriptors,
  losses_entry__field_indices_by_name,
  1,  losses_entry__number_ranges,
  (ProtobufCMessageInit) losses_entry__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor losses_totals__field_descriptors[5] =
{
  {
    "lineLosses",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesTotals, linelosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "transformerLosses",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesTotals, transformerlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "totalLosses",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesTotals, totallosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "totalLoadPower",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesTotals, totalloadpower),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "totalPctLosses",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(LossesTotals, totalpctlosses),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned losses_totals__field_indices_by_name[] = {
  0,   /* field[0] = lineLosses */
  3,   /* field[3] = totalLoadPower */
  2,   /* field[2] = totalLosses */
  4,   /* field[4] = totalPctLosses */
  1,   /* field[1] = transformerLosses */
};
static const ProtobufCIntRange losses_totals__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor losses_totals__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.LossesTotals",
  "LossesTotals",
  "LossesTotals",
  "zepben.protobuf.hc.opendss",
  sizeof(LossesTotals),
  5,
  losses_totals__field_descriptors,
  losses_totals__field_indices_by_name,
  1,  losses_totals__number_ranges,
  (ProtobufCMessageInit) losses_totals__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor node_mismatch__field_descriptors[5] =
{
  {
    "bus",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(NodeMismatch, bus),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "node",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    offsetof(NodeMismatch, node),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "currentSum",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(NodeMismatch, currentsum),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pctError",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(NodeMismatch, pcterror),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "maxCurrent",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(NodeMismatch, maxcurrent),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned node_mismatch__field_indices_by_name[] = {
  0,   /* field[0] = bus */
  2,   /* field[2] = currentSum */
  4,   /* field[4] = maxCurrent */
  1,   /* field[1] = node */
  3,   /* field[3] = pctError */
};
static const ProtobufCIntRange node_mismatch__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor node_mismatch__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.NodeMismatch",
  "NodeMismatch",
  "NodeMismatch",
  "zepben.protobuf.hc.opendss",
  sizeof(NodeMismatch),
  5,
  node_mismatch__field_descriptors,
  node_mismatch__field_indices_by_name,
  1,  node_mismatch__number_ranges,
  (ProtobufCMessageInit) node_mismatch__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor kvbase_mismatch__field_descriptors[4] =
{
  {
    "load",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(KVBaseMismatch, load),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "kv",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(KVBaseMismatch, kv),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bus",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(KVBaseMismatch, bus),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "kvBase",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(KVBaseMismatch, kvbase),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned kvbase_mismatch__field_indices_by_name[] = {
  2,   /* field[2] = bus */
  1,   /* field[1] = kv */
  3,   /* field[3] = kvBase */
  0,   /* field[0] = load */
};
static const ProtobufCIntRange kvbase_mismatch__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor kvbase_mismatch__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "zepben.protobuf.hc.opendss.KVBaseMismatch",
  "KVBaseMismatch",
  "KVBaseMismatch",
  "zepben.protobuf.hc.opendss",
  sizeof(KVBaseMismatch),
  4,
  kvbase_mismatch__field_descriptors,
  kvbase_mismatch__field_indices_by_name,
  1,  kvbase_mismatch__number_ranges,
  (ProtobufCMessageInit) kvbase_mismatch__init,
  NULL,NULL,NULL    /* reserved[123] */
};
